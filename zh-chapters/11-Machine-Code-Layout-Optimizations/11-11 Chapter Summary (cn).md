## 章节总结 {.unlisted .unnumbered}

CPU 前端优化总结见表 {@tbl:CPU_FE_OPT}。

----------------------------------------------------------------------------
转换          如何转换？       为什么有用？      最适合于            由谁完成
------------ --------------- --------------- ------------------ ------------
基本块放置     维护热点         未取分支           任何代码，           编译器
(Basic        代码            更便宜；           尤其是具有
block                        更好的缓           大量分支
placement)                   存利用率           的代码

基本块对齐      使用NOPS        更好的缓存         热循环              编译器
(Basic        对齐移动         利用率
block         热点代码
alignment)

函数拆分        将冷代码块拆      更好的缓存        具有复杂CFG          编译器
(Function      分并放置在单      利用率           的函数，当热
splitting      独的函数中                        部分之间有
)                                              大块冷代码时 

函数重新排序     将热点函数       更好的缓存         许多小型热点         链接器
(Function      分组在一起       利用率            函数
splitting)

-----------------------------------------------------------------------------

Table: CPU 前端优化总结。 {#tbl:CPU_FE_OPT}

* 代码布局改进经常被低估，最终被忽略和遗忘。CPU 前端性能问题，例如 I-cache 和 ITLB 未命中，浪费了大量周期，尤其是对于具有大型代码库的应用程序。但即使是小型和中型应用程序也可以从优化机器代码布局中受益。
* 当开发人员试图改善应用程序性能时，他们通常不会首先关注它。他们更喜欢从低垂的果实开始，例如循环展开和向量化。然而，要知道仅仅通过更好的机器代码布局，您就可能获得额外的 5-10%，这仍然很有用。
* 如果您可以为您的应用程序制定一套典型用例，则通常最好使用 LTO、PGO、BOLT 和其他工具。对于大型应用程序，它是改善机器代码布局的唯一实用方法。

\sectionbreak

