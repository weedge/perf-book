

[TODO]:如何测量代码占用空间

# 机器代码布局优化{#sec:secFEOpt}

中央处理器的前端 (FE) 负责提取和解码指令，并将它们传递给无序后端 (BE)。随着新一代处理器执行“马力”的提升，CPU FE 也需要变得更加强大，以保持机器的平衡。如果 FE 无法跟上提供指令的速度，BE 将无法充分利用，整体性能将会下降。这就是为什么 FE 设计为始终超前于实际执行，以平滑可能发生的任何 hiccup 并始终准备好要执行的指令。例如，2016 年发布的 Intel Skylake 每周期可以提取最多 16 条指令。

大多数情况下，CPU FE 的低效率可以描述为 BE 等待执行指令的情况，但 FE 无法提供它们。因此，CPU 周期被浪费而没有做任何实际的有用工作。回想一下，现代 CPU 可以每周期处理多个指令，现在范围从 4 到 8 宽。并非所有可用插槽都填满的情况经常发生。这代表了数据库、编译器、网络浏览器等许多领域的应用程序低效性的来源。

TMA 方法在“前端绑定”指标中捕获 FE 性能问题。它表示 CPU FE 无法向 BE 提供指令（而 BE 本可以接受它们）的周期百分比。大多数现实世界的应用程序都经历了一个非零的“前端绑定”指标，这意味着运行时间的某个百分比将浪费在次优的指令获取和解码上。低于 10% 是常态。如果您看到“前端绑定”指标超过 20%，那么花时间处理它是绝对值得的。

FE 无法将指令传递给执行单元可能有多种原因。大多数情况下，这是由于代码布局不佳导致的，从而导致 I-cache 和 ITLB 利用率低下。拥有庞大代码库（例如数百万行代码）的应用程序尤其容易出现 FE 性能问题。在本章中，我们将介绍一些典型的优化方法来改善机器代码布局并提高程序的整体性能。


 ## 机器代码布局

当编译器将源代码转换为机器代码时，它会生成一个线性的字节序列。[@lst:MachineCodeLayout] 显示了一个小段 C++ 代码的二进制布局示例。一旦编译器完成生成汇编指令，它需要对它们进行编码并按顺序排列在内存中。

代码清单:机器代码布局示例

~~~~ {#lst:MachineCodeLayout .cpp}
  C++ Code        Assembly Listing      Disassembled Machine Code
  ........        ................      ......................... 
if (a <= b)   │    ; a is in edi     │  401125 cmp esi, edi
  bar();      │    ; b is in esi     │  401128 jb 401131
else          │    cmp esi, edi      │  40112a call bar
  baz();      │    jb .label1        │  40112f jmp 401136
              │    call bar()        │  401131 call baz
              │    jmp .label2       │  401136 ...
              │  .label1:            │
              │    call baz()        │
              │  .label2:            │
              │    ...               │
~~~~

代码在二进制文件中放置的方式称为 *机器代码布局*。请注意，对于同一个程序，可以以许多不同的方式布局代码。对于 [@lst:MachineCodeLayout] 中的代码，编译器可能决定反转分支，以便首先调用`baz`。此外，函数`bar`和`baz`的主体可以以两种不同的顺序放置：我们可以先在二进制文件中放置`bar`，然后放置`baz`，或者反转顺序。这会影响指令在内存中放置的偏移量，进而可能会影响生成的二进制文件的性能，正如您将在后面看到的。在本章的以下部分中，我们将介绍一些机器代码布局的典型优化。
