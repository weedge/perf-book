## 问题和练习 {.unlisted .unnumbered}

1. 使用本章讨论的技术解决以下实验作业：
    - `perf-ninja::function_inlining_1` 
    - `perf-ninja::vectorization` 1 & 2
    - `perf-ninja::dep_chains` 1 & 2
    - `perf-ninja::compiler_intrinsics` 1 & 2
    - `perf-ninja::loop_interchange` 1 & 2
    - `perf-ninja::loop_tiling_1`
2. 描述您将采取哪些步骤来找出应用程序是否利用了所有利用 SIMD 代码的机会？
3. 尝试在实际代码上手动进行循环优化（但不要提交）。确保所有测试仍然通过。
4. 假设您正在处理一个 IpCall（每次调用指令）指标非常低的应用程序。您将尝试应用/强制哪些优化？
5. 每天运行您正在使用的应用程序。找到程序中最热的循环。它是向量化的吗？可以强制编译器自动向量化吗？附加问题：循环是由依赖链还是执行吞吐量导致瓶颈？

**AI回答：**

1. **解决实验作业**：
    - 对于 `perf-ninja::function_inlining_1`，您需要检查函数调用是否可以被内联以减少调用开销，并分析内联对性能的影响。
    - 对于 `perf-ninja::vectorization` 1 & 2，您应该分析代码中的循环，看是否有可能通过向量化来并行化计算，以及如何通过编译器优化或手动优化来实现向量化。
    - 对于 `perf-ninja::dep_chains` 1 & 2，您需要识别并优化数据依赖链，可能通过循环变换或重新组织计算来减少依赖性。
    - 对于 `perf-ninja::compiler_intrinsics` 1 & 2，您应该使用编译器提供的内联函数（如SIMD指令）来手动优化代码，以提高性能。
    - 对于 `perf-ninja::loop_interchange` 1 & 2，您需要考虑循环交换，即改变循环的顺序，以改善内存访问模式和缓存利用率。
    - 对于 `perf-ninja::loop_tiling_1`，您应该实施循环平铺（Tiling），将大循环分解为更小的块，以提高缓存利用率和减少内存延迟。

2. **找出应用程序是否利用了所有SIMD代码的机会**：
    - 使用性能分析工具（如Intel VTune Amplifier）来识别程序中的热点。
    - 查看编译器的优化报告，了解哪些循环已经被向量化。
    - 使用编译器的向量化指令（如GCC的`#pragma GCC vectorize`）来强制向量化。
    - 对于关键循环，手动重写代码以使用SIMD指令，并比较性能差异。

3. **手动进行循环优化**：
    - 选择一个实际的代码循环，例如一个计算密集型的循环。
    - 应用循环展开、循环取消开关、循环交换或循环平铺等技术。
    - 确保优化后的代码逻辑正确，并进行单元测试以验证功能。
    - 使用性能分析工具来比较优化前后的性能差异。

4. **处理IpCall指标非常低的应用程序**：
    - 分析程序中的函数调用，看是否有不必要的开销，考虑使用内联函数。
    - 识别并优化数据依赖链，减少循环中的依赖性。
    - 应用循环优化技术，如循环展开和循环平铺，以提高并行性和缓存利用率。
    - 使用编译器内联函数或手动编写SIMD代码来向量化关键循环。

5. **找到程序中最热的循环并分析**：
    - 使用性能分析工具来识别程序中的热点循环。
    - 检查这些循环是否已经被向量化，如果没有，尝试使用编译器优化或手动优化来实现向量化。
    - 分析循环的性能瓶颈，确定是由数据依赖链还是执行吞吐量引起的。如果是数据依赖链，尝试打破依赖链；如果是执行吞吐量，考虑使用更高效的指令或向量化。