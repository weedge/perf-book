# 优化分支预测

到目前为止，我们一直在讨论优化内存访问和计算。然而，还有另一个重要的性能瓶颈类别，我们尚未讨论。它与推测执行有关，这是现代高性能 CPU 核心中普遍存在的一项功能。为了提醒你，可以参考 [@sec:SpeculativeExec] 中我们讨论了如何利用推测执行来提高性能。在本章中，我们将探讨减少分支预测错误次数的技术。

一般来说，现代处理器非常擅长预测分支结果。它们不仅遵循静态预测规则，还检测动态模式。通常，分支预测器保存先前分支结果的历史记录，并尝试猜测下一个结果。然而，当模式变得难以跟踪时，CPU 分支预测器可能会影响性能。

当分支预测错误时，会导致显著的速度惩罚。当这种事件经常发生时，CPU 需要清除所有预测性工作，后来证明是错误的。它还需要清空流水线，并开始填充正确路径的指令。通常，现代 CPU 由于分支预测错误而经历 10 到 20 个周期的惩罚。准确的周期数取决于微架构设计，即流水线的深度和从错误预测中恢复的机制。

分支预测器使用缓存和历史寄存器，因此容易受到与缓存相关的问题的影响，即三个C：

- **强制性缺失（Compulsory misses）**：当采用静态预测时，如果在分支的第一次动态出现时没有可用的动态历史信息，可能会发生误预测。
- **容量缺失（Capacity misses）**：由于程序中分支数量极高或动态模式非常长，导致动态历史丢失，从而产生误预测。
- **冲突缺失（Conflict misses）**：分支通过它们的虚拟地址和/或物理地址的组合被映射到缓存桶（关联集合）中。如果太多活跃的分支被映射到同一个集合，就可能发生历史丢失。冲突缺失的另一个例子是虚伪共享，当两个独立的分支被映射到同一个缓存条目时，它们可能会相互干扰，从而可能降低预测历史的质量。

程序总是会有非零数量的分支误预测。你可以通过查看TMA（Top-Down Microarchitecture Analysis）的`Bad Speculation`（错误推测）指标来了解程序受分支误预测的影响程度。对于通用应用程序来说，`Bad Speculation`指标在5-10%的范围内是正常的。我们建议一旦这个指标超过10%，就要密切关注。

由于分支预测器擅长发现模式，过去优化分支预测的老建议已经不再适用。过去，开发者可以选择以分支指令的编码前缀形式向处理器提供预测提示（例如`0x2E: Branch Not Taken`, `0x3E: Branch Taken`）。这可能在旧的微架构上，如Pentium 4上提高性能。虽然使用这些分支前缀仍然可以得到有效的x86/x64汇编代码，但在现代处理器上不会产生性能提升。

减少分支误预测的一个间接方法是使用基于源代码和编译器的技术来简化代码。PGO（Profile-Guided Optimization，基于性能分析的优化）和BOLT（一种优化工具）通过提高fallthrough率来减少分支误预测，从而减轻分支预测器结构的压力。我们将在下一章讨论这些技术。

所以，也许直接消除分支误预测的唯一方法就是消除分支本身。在接下来的两个部分中，我们将探讨如何用查找表和预测来替换分支。

有一个传统观点认为，永远不会执行的分支对分支预测是透明的，不会影响性能，因此从预测的角度来看，移除它们并没有太大意义。然而，与这一观点相反，BOLT优化器的作者进行的实验表明，在大型代码足迹的应用程序中，如Clang C++编译器，用等大小的nop指令替换永远不会执行的分支，可以在现代Intel CPU上带来大约5%的速度提升。所以，尝试消除所有分支仍然是值得的。